
/*
Главный предикат - решить_кроссворд/6 - сюда передаются данные из
интерфейса через jpl.
=======================================
Интерфейсный предикат - предикат, который следует использовать для
пользовательских нужд в основном предикате решить_кроссворд/6 (в
отличие от сервисных предикатов - слж_***).
=======================================
слж_*** - служебные предикаты, созданные для уменьшения передаваемых
термов (удобнее вызывать без всяких счётчиков, первоначальных пустых
списков и т.д.)
=======================================
Индексация списков идёт с 1,а не с 0!
=======================================
Термины: по тексту - "пометить" означает занести в список в данную
ячейку число 0 (не пройдена), либо число 3 (точно не закрашена);
"закрасить" - означает занести в список в данную ячейку число 2
(закрашена). Первоначально все ячейки содержат "не пройдено".
=======================================
Домен - это участок линии, который будет закрашен в любом случае.
=======================================
*/


/* Мнемонические обозначения состояний ячеек */
значениеЯчейки("Не пройдена",0).
значениеЯчейки("Возможно закрашена",1).
значениеЯчейки("Закрасить",2).
значениеЯчейки("Не закрашена",3).


/* Оповещаем интерпретатор, то эти предикаты динамические */
:-dynamic состоянияСтолбцов/2.
:-dynamic состоянияСтрок/2.
:-dynamic списокГруппПоСтолбцам/2.
:-dynamic списокГруппПоСтрокам/2.
:-dynamic перестановка/3.
:-dynamic параметры/2.
:-dynamic хэшсумма/1.
:-dynamic хэшсумма_линии/2.









/* == Группа предикатов ==
*  = решить_кроссворд/6 =
* <Назначение>
   Основной предикат программы. Сюда передаются данные
   от Java-интерфейса.
* </Назначение>
*/


%случай1: Проверка на минимальный размер кроссворда (4 ячейки)
решить_кроссворд(_,
		СписокГруппПоСтрокам,
		 _,
		 _,
		 _,
		 _):-
	length(СписокГруппПоСтрокам,ДлинаЛинииПоСтрокам),
	=<(ДлинаЛинииПоСтрокам,3),
	writeln('Кроссворд слишком простой! По строкам должно быть хотя бы 4 клетки!').

%случай2: Проверка на минимальный размер кроссворда (4 ячейки)
решить_кроссворд(СписокГруппПоСтолбцам,
		 _,
		 _,
		 _,
		 _,
		 _):-
	length(СписокГруппПоСтолбцам,ДлинаЛинииПоСтолбцам),
	=<(ДлинаЛинииПоСтолбцам,3),
	writeln('Кроссворд слишком простой! По столбцам должно быть хотя бы 4 клетки!').


%случай3:
/*если в кроссворде больше 40% линий имеют по 1 группе и в сумма чисел в группе больше
 половины линии - в целях отладки - пока единственный вариант
*/
решить_кроссворд(СписокГруппПоСтолбцам,
		СписокГруппПоСтрокам,
		 СостоянияСтолбцов,
		 СостоянияСтрок,
		ВыходныеСтроки,
		ВыходныеСтолбцы):-

	length(СписокГруппПоСтрокам,Высота),
	length(СписокГруппПоСтолбцам,Ширина),

/*	по_одной_группе_имеют(СписокГруппПоСтолбцам,1,Колво1),
	по_одной_группе_имеют(СписокГруппПоСтрокам,1,Колво2),



	is(X,+(Колво1,Колво2)),
	is(ОбщееЧисло,+(Ширина,Высота)),

	узнать_количество_процентов(ОбщееЧисло, X, Результат),
	>=(40, Результат),

	is(Половина1, //(Высота,2)),
	сколько_закрашенных_более(Половина1, СписокГруппПоСтолбцам,1,Результат2),
	is(Половина2, //(Ширина,2)),
	сколько_закрашенных_более(Половина2, СписокГруппПоСтолбцам,1,Результат3),

	is(X1, +(Результат2,Результат3)),
	узнать_количество_процентов(ОбщееЧисло, X1, Результат4),
	>=(40, Результат4),

*/
	очистить_бд,
/*	заполнить_бд_состоянияСтолбцов(СостоянияСтолбцов, 1),
	заполнить_бд_состоянияСтрок(СостоянияСтрок, 1),
	заполнить_бд_списокГруппПоСтолбцам(СписокГруппПоСтолбцам, 1),
	заполнить_бд_списокГруппПоСтрокам(СписокГруппПоСтрокам, 1),*/

/*	примитивные_эвристики(СостоянияСтолбцов,

			     СостоянияСтрок,
			     СписокГруппПоСтолбцам,
			     СписокГруппПоСтрокам,
			     ВыходСтолбцы,
			     ВыходСтроки
			     ),


	синхронизировать_столбцы_и_строки(ВыходСтолбцы,ВыходСтроки,ВыходСтолбцы2,ВыходСтроки2),
*/
	is(Инкремент,+(1,Ширина)),


	поиск_доменов(СостоянияСтолбцов, СписокГруппПоСтолбцам,1),
	поиск_доменов(СостоянияСтрок, СписокГруппПоСтрокам,Инкремент),

	закраска_доменов_столбцы(Ширина,Высота,1,[],ВыходСтолбцы3),
	закраска_доменов_строки(Ширина,Высота,Инкремент,[],ВыходСтроки3),




	синхронизировать_столбцы_и_строки(ВыходСтолбцы3,ВыходСтроки3,ВыходСтолбцы4,ВыходСтроки4),


	% Заполнить 3-ми в тех местах, где уже точно незакрашено

        заполнить_все_оставшиеся_клетки_если_все_группы_заполнены(ВыходСтолбцы4,
								          СписокГруппПоСтолбцам,
									 [],
									 ВыходСтолбцы5),
        заполнить_все_оставшиеся_клетки_если_все_группы_заполнены(ВыходСтроки4,
								          СписокГруппПоСтрокам,
									 [],
									 ВыходСтроки5),


	синхронизировать_столбцы_и_строки(ВыходСтолбцы5,ВыходСтроки5,ВыходСтолбцы6,ВыходСтроки6),




         %перебор_столбцов(СписокГруппПоСтолбцам,ВыходСтолбцы6,1,[], ВыходСтолбцы7),
	 перебор_линий(СписокГруппПоСтрокам,ВыходСтроки6,Инкремент,[],
	 ВыходСтроки7),

	синхронизировать_столбцы_и_строки(ВыходСтолбцы6,ВыходСтроки6,ВыходСтолбцы10,ВыходСтроки10),



	=(ВыходСтолбцы10,ВыходныеСтолбцы),
	=(ВыходСтроки10,ВыходныеСтроки),

	очистить_бд,
	аннулировать_предикаты.













/* == Группа предикатов ==
*  = заполнить_бд_состоянияСтолбцов/2 =
* <Назначение>
*	 Заполняют базу данных интерпретатора состояниями столбцов,
*		 переданных из граф. интерфейса
* </Назначение>
*/
заполнить_бд_состоянияСтолбцов([],_).
заполнить_бд_состоянияСтолбцов([H|T],Счётчик):-
	assertz(состоянияСтолбцов(Счётчик, H)),
	is(НовыйСчётчик, +(Счётчик,1)),
	заполнить_бд_состоянияСтолбцов(T, НовыйСчётчик).

/* == Группа предикатов ==
*  = заполнить_бд_состоянияСтрок/2 =
* <Назначение>
*	 Заполняют базу данных интерпретатора состояниями строк,
*		 переданных из граф. интерфейса
* </Назначение>
*/
заполнить_бд_состоянияСтрок([],_).
заполнить_бд_состоянияСтрок([H|T],Счётчик):-
	assertz(состоянияСтрок(Счётчик, H)),
	is(НовыйСчётчик, +(Счётчик,1)),
	заполнить_бд_состоянияСтрок(T, НовыйСчётчик).

/* == Группа предикатов ==
*  = заполнить_бд_списокГруппПоСтолбцам/2 =
* <Назначение>
*	 Заполняют базу данных интерпретатора списком групп по столбцам,
*		 полученным из граф. интерфейса
* </Назначение>
*/
заполнить_бд_списокГруппПоСтолбцам([],_).
заполнить_бд_списокГруппПоСтолбцам([H|T],Счётчик):-
	assertz(списокГруппПоСтолбцам(Счётчик, H)),
	is(НовыйСчётчик, +(Счётчик,1)),
	заполнить_бд_списокГруппПоСтолбцам(T, НовыйСчётчик).

/* == Группа предикатов ==
*  = заполнить_бд_списокГруппПоСтрокам/2 =
* <Назначение>
*	 Заполняют базу данных интерпретатора списком групп по строкам,
*		 полученным из граф. интерфейса
* </Назначение>
*/
заполнить_бд_списокГруппПоСтрокам([],_).
заполнить_бд_списокГруппПоСтрокам([H|T],Счётчик):-
	assertz(списокГруппПоСтрокам(Счётчик, H)),
	is(НовыйСчётчик, +(Счётчик,1)),
	заполнить_бд_списокГруппПоСтрокам(T, НовыйСчётчик).

/* == Предикат ==
*  = очистить_бд/0 =
* <Назначение>
*	 Очищает базу данных от следующих предикатов:
*			- состоянияСтолбцов/2
*			- состоянияСтрок/2
*			- списокГруппПоСтолбцам/2
*			- списокГруппПоСтрокам/2
*			- перестановка/3
*			- параметры/2
*			- хэшсумма/1
*                       - хэшсумма_линии/2
* </Назначение>
*/
очистить_бд:-
	retractall(состоянияСтолбцов(_,_)),retractall(состоянияСтрок(_,_)),
	retractall(списокГруппПоСтолбцам(_,_)),retractall(списокГруппПоСтрокам(_,_)),
	retractall(перестановка(_,_,_)), retractall(параметры(_,_)),
        retractall(хэшсумма(_)),
	retractall(хэшсумма_линии(_,_)).

/* == Предикат ==
*  = аннулировать_предикаты/0 =
* <Назначение>
*	 Аннулирует следующие предикаты:
*			- состоянияСтолбцов/2
*			- состоянияСтрок/2
*			- списокГруппПоСтолбцам/2
*			- списокГруппПоСтрокам/2
*			- перестановка/3
*			- параметры/2
*			- хэшсумма/1
*                       - хэшсумма_линии/2
* </Назначение>
*/

аннулировать_предикаты:-
	abolish(состоянияСтолбцов/2),
	abolish(состоянияСтрок/2),
	abolish(списокГруппПоСтолбцам/2),
	abolish(списокГруппПоСтрокам/2),
	abolish(перестановка/3),
	abolish(параметры/2),
	abolish(хэшсумма/1),
	abolish(хэшсумма_линии/2).


/* == Группа предикатов ==
*  = есть_ли_в_линии_непройденные_ячейки/1 =
* <Назначение>
*    Получает на вход линию и проверяет, есть ли в её составе
*    непройденные ячейки (цифры 0).
* </Назначение>
*/

есть_ли_в_линии_непройденные_ячейки([]):-fail.
есть_ли_в_линии_непройденные_ячейки([H|_]):-
	=:=(H, 0),!.
есть_ли_в_линии_непройденные_ячейки([H|T]):-
	=\=(H, 0),есть_ли_в_линии_непройденные_ячейки(T).


/* == Группа предикатов ==
*  = есть_ли_в_линии_закрашенные_ячейки/1 =
* <Назначение>
*    Получает на вход линию и проверяет, есть ли в её составе
*    закрашенные ячейки (цифры 2).
* </Назначение>
*/

есть_ли_в_линии_закрашенные_ячейки([]):-fail.
есть_ли_в_линии_закрашенные_ячейки([H|_]):-
	=:=(H, 2),!.
есть_ли_в_линии_закрашенные_ячейки([H|T]):-
	=\=(H, 2),есть_ли_в_линии_закрашенные_ячейки(T).


/* == Предикат ==
*  = проверка_смещения/3 =
* <Назначение>
*    Используется, чтобы узнать - возможно ли по данному смещению
*    в линии закрасить данное число групп
* </Назначение>
*/

проверка_смещения(СписокСостояний,СписокГрупп,Смещение):-
	length(СписокСостояний,КолвоСостояний),
	length(СписокГрупп, КолвоГрупп),
	sumlist(СписокГрупп, СуммаВГруппе),
	is(X,-(КолвоГрупп,1)),
	is(Y,+(СуммаВГруппе,X)),
	>=(+(1,КолвоСостояний),+(Смещение,Y)).


/* == Группа предикатов ==
*  = пометить_до_смещения_если_возможно/3 =
* <Назначение>
*   Используются, чтобы пометить тройками ("точно не закрашено")
*   линию до того как начнут идти закрашенные группы
* </Назначение>
*/
% случай1: группы начинаются не с 1 номера в линии
пометить_до_смещения_если_возможно(СписокСостояний,Счётчик,ВыходнаяЛиния):-
		is(СчётчикМинус1, -(Счётчик,1)),
		>(СчётчикМинус1, 0),
		изменить_ячейки_с_номера(СписокСостояний,
			1,
			СчётчикМинус1,
			"Не закрашена",
			ВыходнаяЛиния).

% случай2: группы начинаются с 1 номера в линии, закрашивать нечего
пометить_до_смещения_если_возможно(СписокСостояний,Счётчик,ВыходнаяЛиния):-
		is(СчётчикМинус1, -(Счётчик,1)),
		=:=(СчётчикМинус1, 0),
		=(СписокСостояний,ВыходнаяЛиния).


/* == Группа предикатов ==
*  = пометить_после_смещения_если_возможно/3 =
* <Назначение>
*   Используются, чтобы пометить тройками ("точно не закрашено")
*   линию после того как закончатся закрашенные группы
* </Назначение>
*/
% случай1: нечего помечать, уже за пределами линии
пометить_после_смещения_если_возможно(СписокСостояний,Счётчик,ВыходнаяЛиния):-
		length(СписокСостояний, Длина),
		is(X, -(Длина, Счётчик)),
		<(X, 0),
		=(СписокСостояний, ВыходнаяЛиния).

% случай2: на линии ещё осталось, что пометить 3
пометить_после_смещения_если_возможно(СписокСостояний,Счётчик,ВыходнаяЛиния):-
		length(СписокСостояний, Длина),
		is(X, -(Длина, Счётчик)),
		>=(X, 0),
		is(Y, +(X,1)),

		изменить_ячейки_с_номера(СписокСостояний,
			Счётчик,
			Y,
			"Не закрашена",
			ВыходнаяЛиния).


/* == Группа предикатов ==
*  = слж_закрасить_линию_со_смещением/5 =
* <Назначение>
*   Используется в слж_поиск_доменов/4 (определение домена наверху).
*   Закрашивает линию СписокСостоянийЛинии, количество закрашенных
*   ячеек - H, если возможно, то ставит промежуток в 1 ячейку
*   (помечает 3), если начинает следующую группу же исчерпали все
*   группы, то предикат доказан.
*   ПоложениеПервойГруппы нужно для того, чтобы знать,
*   где начинаются двойки, иначе
*   пометить_до_смещения_если_возможно/3 всё закрасит
* </Назначение>
*/

слж_закрасить_линию_со_смещением(ВыходнойСписок,[],_,_, ВыходнойСписок).
%случай1: в группе столько же ячеек сколько и в линии, закрасить всё
% и унифицировать полученную строку с выходной.
слж_закрасить_линию_со_смещением(СписокСостоянийЛинии,
		    [H|_],
		    ПоложениеПервойГруппы,
		    Счётчик,
		    ВыходнойСписок):-

	пометить_до_смещения_если_возможно(СписокСостоянийЛинии, ПоложениеПервойГруппы, ВыходнаяЛиния0),


	изменить_ячейки_с_номера(ВыходнаяЛиния0,
			Счётчик,
			H,
			"Закрасить",
			ВыходнаяЛиния2),


	length(ВыходнаяЛиния2, ДлинаЛинии),


	=:=(H,ДлинаЛинии),

	=(ВыходнойСписок, ВыходнаяЛиния2).


% случай2: на линии всё ещё можно закрасить группу и поставить
% 3 в единичный промежуток после группы
слж_закрасить_линию_со_смещением(СписокСостоянийЛинии,
		    [H|T],
		    ПоложениеПервойГруппы,
		    Счётчик,
		    ВыходнойСписок):-

	пометить_до_смещения_если_возможно(СписокСостоянийЛинии, ПоложениеПервойГруппы, ВыходнаяЛиния0),

	изменить_ячейки_с_номера(ВыходнаяЛиния0,
			Счётчик,
			H,
			"Закрасить",
			ВыходнаяЛиния),

	is(НовыйСчётчик, +(Счётчик, H)),
	length(ВыходнаяЛиния, ДлинаЛинии),

	>=(ДлинаЛинии, НовыйСчётчик),

	изменить_ячейки_с_номера(ВыходнаяЛиния,
			НовыйСчётчик,
			1,
			"Не закрашена",
			ЕщёОднаВыходнаяЛиния),
	is(ЕщёОдинНовыйСчётчик, +(НовыйСчётчик, 1)),

	пометить_после_смещения_если_возможно(ЕщёОднаВыходнаяЛиния,ЕщёОдинНовыйСчётчик, ВыходнаяЛиния2),

	слж_закрасить_линию_со_смещением(ВыходнаяЛиния2,
			   T,
			   ПоложениеПервойГруппы,
			   ЕщёОдинНовыйСчётчик,
			   ВыходнойСписок
			   ).



% случай3: если на то, чтобы поставить 3 уже не хватает места
слж_закрасить_линию_со_смещением(СписокСостоянийЛинии,
		    [H|_],
		    ПоложениеПервойГруппы,
		    Счётчик,
		    ВыходнойСписок
			):-
	пометить_до_смещения_если_возможно(СписокСостоянийЛинии, ПоложениеПервойГруппы, ВыходнаяЛиния0),


	изменить_ячейки_с_номера(ВыходнаяЛиния0,
			Счётчик,
			H,
			"Закрасить",
			ВыходнаяЛиния),

	is(НовыйСчётчик, +(Счётчик, H)),
	length(СписокСостоянийЛинии, ДлинаЛинии),
	=<(ДлинаЛинии, НовыйСчётчик),
	=(ВыходнойСписок, ВыходнаяЛиния).

%случай4: иная ситуация - унификация текущего списка состояний
% с выходным
слж_закрасить_линию_со_смещением(ВыходнойСписок,_,_,_,ВыходнойСписок).



/* == Группа предикатов ==
*  = слж_поиск_доменов/4 =
* <Назначение>
     Ищет домены и заносит их в БД как предикаты
     перестановка/3
* </Назначение>
*/
%случай1: есть возможность искать домены
слж_поиск_доменов(СписокСостояний,
		 СписокГрупп,
		 Смещение,
		 НомерЛинии
		 ):-
	проверка_смещения(СписокСостояний,СписокГрупп,Смещение),
	слж_закрасить_линию_со_смещением(СписокСостояний,СписокГрупп,Смещение,Смещение,ВыходнойСписок),
	is(НовоеСмещение, +(Смещение,1)),

	assertz(перестановка(Смещение,НомерЛинии,ВыходнойСписок)),
	слж_поиск_доменов(СписокСостояний,
			 СписокГрупп,
			 НовоеСмещение,
			 НомерЛинии).



% случай2: нет возможности искать домены - предикат доказан.
слж_поиск_доменов(_,_,_,_).

/* == Группа предикатов ==
*  = поиск_доменов/3 =
* <Назначение>
     Устанавливает истинность слж_поиск_доменов
     с различными линиями/группами + проводит проверку
     на наличие частично закрашенных линий - если они есть,
     то уже надо прибегать к другим методам, например, дополнение
     уже имеющихся групп.
* </Назначение>
*/

поиск_доменов([],_,_).
% случай1: в линии есть закрашенные клетки
поиск_доменов([H1|T1],[_|T2],Счётчик):-
	есть_ли_в_линии_закрашенные_ячейки(H1),
	% другие методы
	is(НовыйСчётчик, +(Счётчик,1)),
	поиск_доменов(T1, T2, НовыйСчётчик).

% случай2: в линии нет закрашенных клеток
поиск_доменов([H1|T1],[H2|T2],Счётчик):-
	слж_поиск_доменов(H1,H2,1,Счётчик),
	is(НовыйСчётчик, +(Счётчик,1)),
	поиск_доменов(T1,T2, НовыйСчётчик).


найти_неизменные_участки([],Счётчик, ПредыдущийСписок,ВыходнаяЛиния):-
		изменить_ячейки_с_номера(ПредыдущийСписок,
			Счётчик,
			1,
			"Закрашена",
			ВыходнаяЛиния).


найти_неизменные_участки([H|T],Счётчик, ПредыдущийСписок, ВыходнаяЛиния):-
	=\=(H, 2),
	is(НовыйСчётчик,+(Счётчик,1)),
	найти_неизменные_участки(T, НовыйСчётчик, ПредыдущийСписок,ВыходнаяЛиния).


найти_неизменные_участки([H|T],Счётчик, ПредыдущийСписок, ВыходнаяЛиния):-

	=:=(H, 2),

	findall(Состояние,
		значениеЯчейки("Не пройдена",Состояние),
		ВременныйСписок),
	append(ПредыдущийСписок,
	       ВременныйСписок,
	       НовыйПредыдущийСписок),
/*	writeln('ПредСписок'),
	writeln(ПредыдущийСписок),*/

	is(НовыйСчётчик,+(Счётчик,1)),
	найти_неизменные_участки(T,НовыйСчётчик, НовыйПредыдущийСписок,ВыходнаяЛиния).



/* == Группа предикатов ==
*  = на_этом_индексе_во_всех_списках_закрашено/2 =
* <Назначение>
     Устанавливает истинность того, что на индексе
     Номер ячейки закрашены (2) на всех переданных списках
     (это используется, чтобы просматривать списки перестановок,
     и устанавливать, на каких позициях клетки гарантированно
     закрашены)
* </Назначение>
*/

на_этом_индексе_во_всех_списках_закрашено(_, []).

%случай1: в каком-то списке этот элемент не закрашен
на_этом_индексе_во_всех_списках_закрашено(Номер, [H|_]):-
	nth1(Номер, H, Элемент),
	=\=(Элемент, 2),fail.

%случай2: в данном списке элемент закрашен - идём дальше
на_этом_индексе_во_всех_списках_закрашено(Номер, [H|T]):-
	nth1(Номер, H, Элемент),
	=:=(Элемент, 2),
	на_этом_индексе_во_всех_списках_закрашено(Номер,T).


/* == Группа предикатов ==
*  = слж_искать_в_списке_перестановок/5 =
* <Назначение>
    Ищет зоны закрашенных клеток, иначе говоря,
    какие клетки точно будут закрашены
* </Назначение>
*/

слж_искать_в_списке_перестановок(_,ДлинаСписков,ДлинаСписков,Выход,Выход).

% случай1: на индексе Счётчик закрашено во всех списках и поэтому
% индекс Счётчик входит в зону уверенной закраски
слж_искать_в_списке_перестановок(СписокСписков,Счётчик,ДлинаСписков,ПредыдущийВыход, Выход):-

	на_этом_индексе_во_всех_списках_закрашено(Счётчик, СписокСписков),

	findall(Состояние,
		значениеЯчейки("Закрасить",Состояние),
		ВременныйСписок),

	append(ПредыдущийВыход,
	       ВременныйСписок,
	       ТекущаяЛиния),

	is(НовыйСчётчик,+(1,Счётчик)),
	слж_искать_в_списке_перестановок(СписокСписков,НовыйСчётчик,ДлинаСписков,ТекущаяЛиния,Выход).

% случай2: на индексе Счётчик не закрашено во всех списках и поэтому
% индекс Счётчик не входит в зону уверенной закраски
слж_искать_в_списке_перестановок(СписокСписков,Счётчик,ДлинаСписков,ПредыдущийВыход, Выход):-
	findall(Состояние,
		значениеЯчейки("Не пройдена",Состояние),
		ВременныйСписок),

	append(ПредыдущийВыход,
	       ВременныйСписок,
	       ТекущаяЛиния),

	is(НовыйСчётчик,+(1,Счётчик)),
	слж_искать_в_списке_перестановок(СписокСписков,НовыйСчётчик,ДлинаСписков,ТекущаяЛиния,Выход).



/* == Группа предикатов ==
*  = закраска_доменов_столбцы/5 =
* <Назначение>
    Интерфейсный предикат, доказывает слж_искать_в_списке_перестановок.
    Проходится по всем столбцам, передавая каждый последнему в качестве
    линии
* </Назначение>
*/

% случай1: Счётчик вышел за необходимые границы (для столбцов - ширина
% кроссворда)
закраска_доменов_столбцы(Ширина,_,Счётчик,Выходной,Выходной):-
	>(Счётчик, Ширина).

% случай2: Счётчик в норме, ищутся зоны уверенной закраски
закраска_доменов_столбцы(Ширина,Высота,Счётчик,Предыдущий,ВыходнойСписок):-
	is(НовыйСчётчик, +(Счётчик,1)),
	findall(Var,перестановка(_,Счётчик,Var), Перестановки),
	is(НоваяВысота,+(Высота,1)),
	слж_искать_в_списке_перестановок(Перестановки,1,НоваяВысота,[], ВыходнаяЛиния),
	append(Предыдущий,
	       [ВыходнаяЛиния],
	       Текущий),

	закраска_доменов_столбцы(Ширина,Высота,НовыйСчётчик,Текущий,ВыходнойСписок).


/* == Группа предикатов ==
*  = закраска_доменов_строки/5 =
* <Назначение>
    Интерфейсный предикат, доказывает слж_искать_в_списке_перестановок.
    Проходится по всем строкам, передавая каждую последнему в качестве
    линии
* </Назначение>
*/

% случай1: Счётчик вышел за необходимые границы (для строк - ширина
% + высота кроссворда, так как заполнение перестановка/3 идет так:
% сначала заносятся перестановки столбцов - это Ширина раз, далее ещё
% перестановки строк - это Ширина+Высота раз)
закраска_доменов_строки(Ширина,Высота,Счётчик,Выходной,Выходной):-
	is(НоваяВысота,+(Высота, Ширина)),
	>(Счётчик, НоваяВысота).

% случай2: Счётчик в норме, ищутся зоны уверенной закраски
закраска_доменов_строки(Ширина,Высота,Счётчик,Предыдущий,ВыходнойСписок):-

	is(НовыйСчётчик, +(Счётчик,1)),
	findall(Var,перестановка(_,Счётчик,Var), Перестановки),

	is(НоваяШирина,+(Ширина,1)),
	слж_искать_в_списке_перестановок(Перестановки,1,НоваяШирина,[], ВыходнаяЛиния),
	append(Предыдущий,
	       [ВыходнаяЛиния],
	       Текущий),
	writeln('ВыходнаяУСтроки'),
	writeln(ВыходнаяЛиния),
	закраска_доменов_строки(Ширина,Высота,НовыйСчётчик,Текущий,ВыходнойСписок).

/*
слж_перебор_линии_для_вариантов_дополнения(Выход,_,0,_,Выход).
слж_перебор_линии_для_вариантов_дополнения(Выход,_,_,Счётчик,Выход):-
	length(Выход, Длина),
	>(Счётчик, Длина).


слж_перебор_линии_для_вариантов_дополнения(ВходнойСписок,
					   [H|T],
					   КолвоЗакрашенныхВГруппе,
					   Счётчик,
					   Выход):-
	=\=(H, 2),
	изменить_ячейки_с_номера(ВходнойСписок,
			Счётчик,
			1,
			"Закрасить",
			ВыходнаяЛиния),

	is(НовыйСчётчик, +(Счётчик,1)),
	is(НовоеКолвоЗакрашенных, -(КолвоЗакрашенныхВГруппе,1)),
	слж_перебор_линии_для_вариантов_дополнения(ВыходнаяЛиния,
						   T,
						   НовоеКолвоЗакрашенных,
						   НовыйСчётчик,
						   Выход).

слж_перебор_линии_для_вариантов_дополнения(ВходнойСписок,[H|T],КолвоЗакрашенныхВГруппе, Счётчик,Выход):-
	=:=(H, 2),
	is(НовыйСчётчик, +(Счётчик,1)),
	is(НовоеКолвоЗакрашенных, -(КолвоЗакрашенныхВГруппе,1)),

	слж_перебор_линии_для_вариантов_дополнения(ВходнойСписок,T, НовоеКолвоЗакрашенных,НовыйСчётчик,Выход).


слж_перебор_групп_для_вариантов_дополнения(Выход,[],_,Выход).
слж_перебор_групп_для_вариантов_дополнения(Выход,[],Счётчик,Выход):-
	length(Выход,Длина),
	>(Счётчик, Длина).
слж_перебор_групп_для_вариантов_дополнения(Линия, [H|T],Счётчик,Выход):-
	слж_перебор_линии_для_вариантов_дополнения(Линия,Линия, H,Счётчик,ВыходнаяЛиния),
	is(НовыйСчётчик, +(Счётчик,H)),
%	is(НовыйСчётчик, +(ВремСчётчик,1)),
	слж_перебор_групп_для_вариантов_дополнения(ВыходнаяЛиния, T, НовыйСчётчик,Выход).


слж_перебор_линий_для_дополнения_столбцы(Линия, Группы,Выход):-
	есть_ли_в_линии_непройденные_ячейки(Линия),
	слж_перебор_групп_для_вариантов_дополнения(Линия,Группы,1,Выход).

слж_перебор_линий_для_дополнения_столбцы(Выход, _,Выход).

дополнение_неполных_групп_столбцы([],_,Выход,Выход).

дополнение_неполных_групп_столбцы([H1|T1],[H2|T2],Предыдущий,ВыходныеСтолбцы):-
	слж_перебор_линий_для_дополнения_столбцы(H1,H2,ВыходСтолбец),
	append(Предыдущий,
	       [ВыходСтолбец],
	       Текущий),
	дополнение_неполных_групп_столбцы(T1,T2,Текущий,ВыходныеСтолбцы).
*/


/* == Группа предикатов ==
*  = узнать_количество_закрашенных_клеток/3 =
* <Назначение>
    Помещает в КоличествоЗакрашенных количество закрашенных ячеек
    в линии первого аргумента (передаётся через голову и хвост).
    Текущее количество служит для дальнейшей унификации с выходным
    значением.
* </Назначение>
*/

узнать_количество_закрашенных_клеток([],КоличествоЗакрашенных,КоличествоЗакрашенных).

%случай1: элемент закрашен, увеличить счётчик
узнать_количество_закрашенных_клеток([H|T], ТекущееКоличество, КоличествоЗакрашенных):-
	=:=(H,2),
	is(НовоеКолво, +(ТекущееКоличество,1)),
	узнать_количество_закрашенных_клеток(T,НовоеКолво,КоличествоЗакрашенных).

%случай2: элемент не закрашен
узнать_количество_закрашенных_клеток([H|T], ТекущееКоличество, КоличествоЗакрашенных):-
	=\=(H,2),
	узнать_количество_закрашенных_клеток(T,ТекущееКоличество,КоличествоЗакрашенных).

/* == Группа предикатов ==
*  = пометить_непройденные_как_пустые/4 =
* <Назначение>
    Помечает непройденные как пустые, то есть изменяет 0
    на 3 в ячейках
* </Назначение>
*/

пометить_непройденные_как_пустые(ВыходнаяЛиния,[],_,ВыходнаяЛиния).

%случай1: элемент непройден - пометить как незакрашенный
пометить_непройденные_как_пустые(СписокСостояний,[H|T],Счётчик,ВыходнаяЛиния):-
	=:=(H,0),
	изменить_ячейки_с_номера(СписокСостояний,
			Счётчик,
			1,
			"Не закрашена",
			Предыдущий),
	is(НовыйСчётчик, +(Счётчик,1)),
	пометить_непройденные_как_пустые(Предыдущий,T,НовыйСчётчик,ВыходнаяЛиния).

%случай2: элемент не является непройденным
пометить_непройденные_как_пустые(СписокСостояний,[H|T],Счётчик,ВыходнаяЛиния):-
	=\=(H,0),
	is(НовыйСчётчик, +(Счётчик,1)),
	пометить_непройденные_как_пустые(СписокСостояний,T,НовыйСчётчик, ВыходнаяЛиния).


/* == Группа предикатов ==
*  = заполнить_все_оставшиеся_клетки_если_все_группы_заполнены/4 =
* <Назначение>
    Доказывает то, что линия заполнена (все группы закрашены)
    и заполняет незаполненные клетки 3-ми, либо доказывает, что
    линия ещё не заполнена
*   </Назначение>
*/

заполнить_все_оставшиеся_клетки_если_все_группы_заполнены([],_,Выход,Выход).
%случай1: линия ещё не заполнена
заполнить_все_оставшиеся_клетки_если_все_группы_заполнены([H1|T1],[H2|T2], Предыдущий,Выход):-
	линия_не_заполнена(H1,H2),
	append(Предыдущий,
	      [H1],
	      Текущий),
	заполнить_все_оставшиеся_клетки_если_все_группы_заполнены(T1, T2,Текущий,Выход).

%случай2: линия заполнена и подвергается дополнению 3-ми
заполнить_все_оставшиеся_клетки_если_все_группы_заполнены([H1|T1],[H2|T2],Предыдущий,Выход):-

	линия_заполнена(H1,H2),


	пометить_непройденные_как_пустые(H1,H1,1,ВыходнаяЛиния),
	append(Предыдущий,
	      [ВыходнаяЛиния],
	      Текущий),

	заполнить_все_оставшиеся_клетки_если_все_группы_заполнены(T1, T2,Текущий,Выход).


/* == Группа предикатов ==
*  = линия_не_заполнена/2 =
* <Назначение>
    Доказывает то, что линия не заполнена.
*   </Назначение>
*/

% случай1: узнаёт сумму списка групп и соотносит её с количеством
% закрашенных ячеек
линия_не_заполнена(СписокСостояний,
		  СписокГрупп):-
	sumlist(СписокГрупп, Сумма),
	узнать_количество_закрашенных_клеток(СписокСостояний, 0, КоличествоЗакрашенных),
	<(КоличествоЗакрашенных, Сумма).

%случай2: КоличествоЗакрашенных клеток равно сумме
линия_не_заполнена(_,_):-fail.


/* == Группа предикатов ==
*  = линия_заполнена/2 =
* <Назначение>
    Доказывает то, что линия заполнена.
*   </Назначение>
*/

%случай1: КоличествоЗакрашенных клеток равно сумме чисел в группах
линия_заполнена(СписокСостояний,
		  СписокГрупп):-
	sumlist(СписокГрупп, Сумма),
	узнать_количество_закрашенных_клеток(СписокСостояний, 0, КоличествоЗакрашенных),
	=:=(Сумма, КоличествоЗакрашенных).

%случай2: КоличествоЗакрашенных клеток не равно сумме чисел в группах
линия_заполнена(_,_):-fail.


/* == Предикат ==
*  = не_возникнет_ли_конфликтов_если_закрасить_данную_ячейку/3 =
* <Назначение>
    Доказывает то, что линия не заполнена до конца, следовательно
    ещё можно заштриховать одну клетку без конфликтов
*   </Назначение>
*/

не_возникнет_ли_конфликтов_если_закрасить_данную_ячейку(СписокСостояний,СписокГрупп,НомерЯчейки):-
	линия_не_заполнена(СписокСостояний, СписокГрупп),
	изменить_ячейки_с_номера(СписокСостояний,
				НомерЯчейки,
				1,
				"Закрасить",
				ВыходнаяЛиния),
       sumlist(СписокГрупп, Сумма),
       узнать_количество_закрашенных_клеток(ВыходнаяЛиния, 0, КоличествоЗакрашенных),
       =<(Сумма, КоличествоЗакрашенных).


/* == Группа предикатов ==
*  = слж_найти_и_заменить_код_строки/3 =
* <Назначение>
    Служебный предикат, используется в
    синхронизировать_столбцы_и_строки/4.
    Действует так: если текущий элемент в строке равен 0,
    то берем элемент списка столбцов по индексу, равному
    номеру найденного 0 в строке и добавляем в синхронизированный
    столбец. Так как ячейка не пройдена, мы не можем ещё однозначно
    пометить или закрасить, возможно при синхронизации
    столбцов возникнет ситуация, когда на этот 0
    встанет 2,3, а закрасив сейчас эту ячейку, мы
    заблокируем её для доступа.
    Блокировка сделана с целью недопущения затирания предыдущих
    этапов синхронизации - на 0 можно вставить 2 или 3,
    а на 2 или 3 уже ничего нельзя вставить (это уже точные состояния)
* </Назначение>
*/


слж_найти_и_заменить_код_строки([],_,_,_,Выход,Выход).

%случай1: элемент равен 0, значит в столбцах ничего не меняем
слж_найти_и_заменить_код_строки([H|T],
			      СписокСтолбцов,
			      НомерСтроки,
			      СчётчикЭлементов,
			      Предыдущий,
			      Выход):-
	=:=(H,0),
	nth1(СчётчикЭлементов,СписокСтолбцов,Столбец),
	append(Предыдущий,
	      [Столбец],
	      Текущий),

	is(НовыйСчётчик, +(СчётчикЭлементов,1)),
	слж_найти_и_заменить_код_строки(T, СписокСтолбцов,НомерСтроки,НовыйСчётчик,Текущий,Выход).

%случай2: элемент не равен 0 и элемент, который находится в столбце,
% взятом из списка столбцов по индексу найденного элемента, по
% индексу номера строки, не равен 0, то есть уже содержит
% точное значение - ничего не делаем со взятым столбцом
слж_найти_и_заменить_код_строки([H|T],
			      СписокСтолбцов,
			      НомерСтроки,
			      СчётчикЭлементов,
			      Предыдущий,
			      Выход):-

	=\=(H,0),
	nth1(СчётчикЭлементов,СписокСтолбцов,Столбец),

	nth1(НомерСтроки,Столбец,ЭлемСтолбца),
	=\=(ЭлемСтолбца, 0),

	append(Предыдущий,
	      [Столбец],
	      Текущий),

	is(НовыйСчётчик, +(СчётчикЭлементов,1)),
	слж_найти_и_заменить_код_строки(T, СписокСтолбцов,НомерСтроки,НовыйСчётчик,Текущий,Выход).



%случай3: элемент не равен 0, значит стоит взять столбец по индексу
% найденного ненулевого элемента, в этом столбце изменить значение
% на индексе равном номеру строки, которую мы первоначально разбирали,
% на значение, равное тому самому ненулевому элементу
слж_найти_и_заменить_код_строки([H|T],
			      СписокСтолбцов,
			      НомерСтроки,
			      СчётчикЭлементов,
			      Предыдущий,
			      Выход):-
	=\=(H,0),
	nth1(СчётчикЭлементов,СписокСтолбцов,Столбец),
	nth1(НомерСтроки,Столбец,ЭлемСтолбца),
	=:=(ЭлемСтолбца,0),


	получить_мнемоническое_обозначение_ячейки(H,МнемОбоз),
		изменить_ячейки_с_номера(Столбец,
				НомерСтроки,
				1,
				МнемОбоз,
				ВыходнаяЛиния),

	append(Предыдущий,
	      [ВыходнаяЛиния],
	      Текущий),



	is(НовыйСчётчик, +(СчётчикЭлементов,1)),
	слж_найти_и_заменить_код_строки(T, СписокСтолбцов,НомерСтроки,НовыйСчётчик,Текущий,Выход).



/* == Группа предикатов ==
*  = слж_найти_и_заменить_код_столбцы/3 =
* <Назначение>
    Служебный предикат, используется в
    синхронизировать_столбцы_и_строки/4.
    Действует так: если текущий элемент в столбце равен 0,
    то берем элемент списка строк по индексу, равному
    номеру найденного 0 в столбце и добавляем в синхронизированную
    строку. Так как ячейка не пройдена, мы не можем ещё однозначно
    пометить или закрасить, возможно при синхронизации
    строк возникнет ситуация, когда на этот 0
    встанет 2,3, а закрасив сейчас эту ячейку, мы
    заблокируем её для доступа.
    Блокировка сделана с целью недопущения затирания предыдущих
    этапов синхронизации - на 0 можно вставить 2 или 3,
    а на 2 или 3 уже ничего нельзя вставить (это уже точные состояния)
* </Назначение>
*/


слж_найти_и_заменить_код_столбцы([],_,_,_,Выход,Выход).

%случай1: элемент равен 0, значит в строках ничего не меняем
слж_найти_и_заменить_код_столбцы([H|T],
			      СписокСтрок,
			      НомерСтолбца,
			      СчётчикЭлементов,
			      Предыдущий,
			      Выход):-
	=:=(H,0),

	nth1(СчётчикЭлементов,СписокСтрок,Строка),

	append(Предыдущий,
	      [Строка],
	      Текущий),

	is(НовыйСчётчик, +(СчётчикЭлементов,1)),
	слж_найти_и_заменить_код_столбцы(T, СписокСтрок,НомерСтолбца,НовыйСчётчик,Текущий,Выход).


%случай2: элемент не равен 0 и элемент, который находится в строке,
% взятой из списка строк по индексу найденного элемента, по
% индексу номера столбца, не равен 0, то есть уже содержит
% точное значение - ничего не делаем со взятой строкой

слж_найти_и_заменить_код_столбцы([H|T],
			      СписокСтрок,
			      НомерСтолбца,
			      СчётчикЭлементов,
			      Предыдущий,
			      Выход):-

	=\=(H,0),
	nth1(СчётчикЭлементов,СписокСтрок,Строка),

	nth1(НомерСтолбца,Строка,ЭлемСтроки),
	=\=(ЭлемСтроки, 0),

	append(Предыдущий,
	      [Строка],
	      Текущий),

	is(НовыйСчётчик, +(СчётчикЭлементов,1)),
	слж_найти_и_заменить_код_столбцы(T, СписокСтрок,НомерСтолбца,НовыйСчётчик,Текущий,Выход).



%случай3: элемент не равен 0, значит стоит взять строку по индексу
% найденного ненулевого элемента, в этой строке изменить значение
% на индексе равном номеру столбца, который мы первоначально разбирали,
% на значение, равное тому самому ненулевому элементу

слж_найти_и_заменить_код_столбцы([H|T],
			      СписокСтрок,
			      НомерСтолбца,
			      СчётчикЭлементов,
			      Предыдущий,
			      Выход):-
	=\=(H,0),
	nth1(СчётчикЭлементов,СписокСтрок,Строка),

	nth1(НомерСтолбца,Строка,ЭлемСтроки),
	=:=(ЭлемСтроки,0),
	получить_мнемоническое_обозначение_ячейки(H,МнемОбозн),

	изменить_ячейки_с_номера(Строка,
				НомерСтолбца,
				1,
				МнемОбозн,
				ВыходнаяЛиния),

	append(Предыдущий,
	      [ВыходнаяЛиния],
	      Текущий),



	is(НовыйСчётчик, +(СчётчикЭлементов,1)),
	слж_найти_и_заменить_код_столбцы(T, СписокСтрок,НомерСтолбца,НовыйСчётчик,Текущий,Выход).



/* == Группа предикатов ==
*  = слж_синхронизация_строки/3 =
* <Назначение>
   Обёртка для слж_найти_и_заменить_код_строки/6.
   Перебирает строки.
* </Назначение>
*/

слж_синхронизация_строки(Выход,[],_,Выход).
%случай1: берем строку по текущему счётчику и синхронизируем
% с зависимыми столбцами
слж_синхронизация_строки(Столбцы,Строки,Счётчик,Выход):-
	nth1(Счётчик, Строки, Строка),
	слж_найти_и_заменить_код_строки(Строка,
				      Столбцы,
				      Счётчик,
				      1,
				      [],
				      ВыходСтолбцы),
	is(НовыйСчётчик, +(Счётчик,1)),

	слж_синхронизация_строки(ВыходСтолбцы,Строки,НовыйСчётчик,Выход).

%случай2: иная ситуация
слж_синхронизация_строки(Выход,_,_,Выход).



/* == Группа предикатов ==
*  = слж_синхронизация_столбцы/3 =
* <Назначение>
   Обёртка для слж_найти_и_заменить_код_столбцы6.
   Перебирает столбцы.
* </Назначение>
*/

слж_синхронизация_столбцы([],Выход,_,Выход).

%случай1: берём столбец по счётчику и синхронизируем
% с зависимыми строками
слж_синхронизация_столбцы(Столбцы,Строки,Счётчик,Выход):-
	nth1(Счётчик, Столбцы, Столбец),
	слж_найти_и_заменить_код_столбцы(Столбец,
				      Строки,
				      Счётчик,
				      1,
				      [],
				      ВыходСтроки),

	is(НовыйСчётчик, +(Счётчик,1)),
	слж_синхронизация_столбцы(Столбцы,ВыходСтроки,НовыйСчётчик,Выход).

%случай2: иная ситуация
слж_синхронизация_столбцы(_,Выход,_,Выход).


/* == Предикат ==
*  = синхронизировать_столбцы_и_строки/4 =
* <Назначение>
  Интерфейсный предикат - применяется в решить_кроссворд,
* </Назначение>
*/

синхронизировать_столбцы_и_строки(Столбцы, Строки,ВыходСтолбцы,ВыходСтроки):-
	слж_синхронизация_строки(Столбцы,Строки,1,ВыходСтолбцы1),
	=(ВыходСтолбцы,ВыходСтолбцы1),
	слж_синхронизация_столбцы(ВыходСтолбцы1,Строки,1,ВыходСтроки).



/* == Группа предикатов ==
*  = вывести_перестановки/3 =
* <Назначение>
   Отладочный предикат.
   Выводит все перестановки для переданного номера линии =
   Счётчик, Предыдущий - служебный список, служит для
   последующей унификации с Выход.
* </Назначение>
*/

%случай1: всё нормально, выводим перестановки из БД
вывести_перестановки(Счётчик,Предыдущий,Выход):-
	findall(Var,перестановка(_,Счётчик,Var), Перестановки),
	length(Перестановки, Длина),
	>(Длина,0),
	append(Предыдущий,
	      [Перестановки],
	      Результат),
	is(НовыйСчётчик, +(Счётчик,1)),
	вывести_перестановки(НовыйСчётчик,Результат,Выход).

%случай2: иная ситуация
вывести_перестановки(_,Выход,Выход).



/* == Группа предикатов ==
*  = слж_счётчик_известных/3 =
* <Назначение>
  Производит подсчёт ячеек, содержащих 2 или 3 в линии
* </Назначение>
*/

слж_счётчик_известных(_,ВыходнойСчётчик,ВыходнойСчётчик).
%случай1: ячейка закрашена, увеличить счётчик
слж_счётчик_известных([H|T],
		       ПредыдущийСчётчик,
		       ВыходнойСчётчик):-
	=:=(H,2),
	is(НовыйСчётчик, +(ПредыдущийСчётчик,1)),
	слж_счётчик_известных(T,НовыйСчётчик,ВыходнойСчётчик).

%случай2: ячейка помечена, увеличить счётчик
слж_счётчик_известных([H|T],
		       ПредыдущийСчётчик,
		       ВыходнойСчётчик):-
	=:=(H,3),
	is(НовыйСчётчик, +(ПредыдущийСчётчик,1)),
	слж_счётчик_известных(T,НовыйСчётчик,ВыходнойСчётчик).

%случай3: иная ситуация
слж_счётчик_известных([_|T],
		       ПредыдущийСчётчик,
		       ВыходнойСчётчик):-
       слж_счётчик_известных(T,ПредыдущийСчётчик,ВыходнойСчётчик).


/* == Предикат ==
*  = известно_менее/2 =
* <Назначение>
     Доказывает, что известно менее "Процентов", ячеек в "Линия".
     Ячейка считается известной,если содержит 2 или 3
* </Назначение>
*/

известно_менее(Процентов, Линия):-
	слж_счётчик_известных(Линия, 0, ВыходнойСчётчик),
	length(Линия, ДлинаЛинии),
	is(X,*(ВыходнойСчётчик, 100)),
	is(Y, /(X,ДлинаЛинии)),
	<(Y,Процентов).


/* == Предикат ==
*  = известно_более/2 =
* <Назначение>
     Доказывает, что известно более "Процентов", ячеек в "Линия".
     Ячейка считается известной,если содержит 2 или 3
* </Назначение>
*/

известно_более(Процентов, Линия):-
	слж_счётчик_известных(Линия, 0, ВыходнойСчётчик),
	length(Линия, ДлинаЛинии),
	is(X,*(ВыходнойСчётчик, 100)),
	is(Y, /(X,ДлинаЛинии)),
	>=(Y,Процентов).



/* == Группа предикатов ==
*  = все_клетки_закрашены_с_по/4 =
* <Назначение>
     Доказывает, что клетки с "С" до "По" в линии "Линия" закрашены
* </Назначение>
*/

%случай1: элемент закрашен
все_клетки_закрашены_с_по(Линия,С,По,Счётчик):-
	is(X,+(С,Счётчик)),
	=\=(X,По),
	nth1(X,Линия,Элемент),
	=:=(Элемент,2),
	is(НовыйСчётчик,+(Счётчик,1)),
	все_клетки_закрашены_с_по(Линия,С,По,НовыйСчётчик).

%случай2: элемент не закрашен
все_клетки_закрашены_с_по(Линия,С,По,Счётчик):-
	is(X,+(С,Счётчик)),
	=\=(X,По),
	nth1(X,Линия,Элемент),
	=\=(Элемент,2),
	fail.

%случай3: счётчик достиг предела
все_клетки_закрашены_с_по(_,С,По,Счётчик):-
	is(X,+(С,Счётчик)),
	=:=(X,По).


/* == Предикат ==
*  = все_клетки_закрашены_с_по/3 =
* <Назначение>
   Управляет предикатом все_клетки_закрашены_с_по/4
* </Назначение>
*/

все_клетки_закрашены_с_по(Линия,С,По):-
	все_клетки_закрашены_с_по(Линия,С,По,0).


/* == Группа предикатов ==
*  = в_линии_нет_противоречий/3 =
* <Назначение>
     Доказывает, что в линии нет таких противоречий как: остались ещё
     группы, а линия закончена, между группами есть минимум одна
     помеченная клетка (3)
* </Назначение>
*/

в_линии_нет_противоречий(_,[],_).
%случай1: обычный случай - в списке групп ещё есть элементы
в_линии_нет_противоречий(Линия,[H|T],Счётчик):-
	length(T, ДлинаОстатка),
	=\=(ДлинаОстатка, 0),
	is(НовыйСчётчик,+(Счётчик,H)),
	is(ТекущееПо, +(Счётчик,H)),
	все_клетки_закрашены_с_по(Линия, НовыйСчётчик, ТекущееПо),
	nth1(ТекущееПо, Линия, Элемент),
	=:=(Элемент, 3),
	is(НовыйСчётчик2,+(НовыйСчётчик,1)),

	в_линии_нет_противоречий(Линия,T,НовыйСчётчик2).

%случай2: в списке групп ещё есть элементы, но линия закончилась
в_линии_нет_противоречий(Линия,[H|T],Счётчик):-
	length(T, ДлинаОстатка),
	=\=(ДлинаОстатка, 0),
	is(ТекущееПо, +(Счётчик,H)),
	length(Линия, ДлинаЛинии),
	>=(ТекущееПо, ДлинаЛинии),
	fail.


%случай3: в группах больше ничего нет
в_линии_нет_противоречий(Линия,[H|T],Счётчик):-
	length(T, ДлинаОстатка),
	=:=(ДлинаОстатка, 0),
	length(Линия, ДлинаЛинии),
	is(ТекущееПо, +(Счётчик,H)),
	=<(ТекущееПо, +(ДлинаЛинии,1)),

	все_клетки_закрашены_с_по(Линия, Счётчик, ТекущееПо).


/* == Предикат ==
*  = в_линиях_нет_противоречий/2 =
* <Назначение>
   Управляет предикатом в_линиях_нет_противоречий/3
   Перебирает линии. Первый аргумент - список линий,
   второй - список групп для них.
* </Назначение>
*/
в_линиях_нет_противоречий([H|T],[H2|T2]):-
	в_линии_нет_противоречий(H, H2, 1),
	в_линиях_нет_противоречий(T,T2).


/* == Группа предикатов ==
*  = слж_заполнить_пустые_места_случайным_образом/3 =
* <Назначение>
   Заполняет пространства между закрашенными (2) и помеченными (3)
   клетками случайной комбинацией чисел в диапазоне [2,3]
* </Назначение>
*/

слж_заполнить_пустые_места_случайным_образом([],Выход,Выход).
%случай1: найдена пустота, генерируем случайное число и записываем
% на место пустоты
слж_заполнить_пустые_места_случайным_образом([H|T],Предыдущий,Выход):-
	=:=(H,0),
	random(2,4,X),
	append(Предыдущий,
	      [X],
	      ТекущийСписок),
	слж_заполнить_пустые_места_случайным_образом(T,ТекущийСписок,Выход).

%случай2: данная ячейка занята - идём дальше
слж_заполнить_пустые_места_случайным_образом([H|T],Предыдущий,Выход):-
	=\=(H,0),
	append(Предыдущий,
	      [H],
	      ТекущийСписок),
	слж_заполнить_пустые_места_случайным_образом(T,ТекущийСписок,Выход).

/* == Предикат ==
*  = заполнить_пустые_места_случайным_образом/2 =
* <Назначение>
   Управляет предикатом слж_заполнить_пустые_места_случайным_образом/3
* </Назначение>
*/
заполнить_пустые_места_случайным_образом(Линия,Выход):-
	слж_заполнить_пустые_места_случайным_образом(Линия,[],Выход).


/* == Группа предикатов ==
*  = перебор_линий/5 =
* <Назначение>
   Заполняет пространства между закрашенными (2) и помеченными (3)
   клетками случайной комбинацией чисел в диапазоне [2,3].
   Группы - список групп для линии,
   [H|T] - список линий
   Номер - номер текущей линии

* </Назначение>
*/
%случай1: линии кончились и в списке состояний нет противоречий - успех.
перебор_линий(Группы,[],_,Выход,Выход):-
	retractall(хэшсумма_линии(_,_)),
	findall(Var,хэшсумма(Var),Хэши),
	term_hash(Выход, Хэш),
	\=(member(Хэши,Хэш),true),
	в_линиях_нет_противоречий(Выход,Группы),
	retractall(хэшсумма(_)).

%случай2: линии кончились, но хэш общего списка уже есть
% в таблице хэшей спиской -> нужно заново перебирать линии
перебор_линий(_,[],_,Выход,Выход):-
	term_hash(Выход, Хэш),
	assertz(хэшсумма(Хэш)),
	fail.

%случай3: сгенерированный случайный вариант линии уже
% есть в хэш-таблице
перебор_линий(_,[H|_],Номер,_,_):-
       % известно_более(50, H),
	заполнить_пустые_места_случайным_образом(H,ВыходнаяЛиния),
	term_hash(ВыходнаяЛиния, Хэш),
	findall(Var,хэшсумма_линии(Номер,Var),ХэшиЛинии),
	member(Хэш,ХэшиЛинии),
	fail.

%случай4: сгенерированного случайного варианта линии нет
% в хэш-таблице
перебор_линий(Группы,[H|T],Номер,ПредыдущийСписок,Выход):-

       % известно_более(50, H),
	is(ТекущийНомер, +(Номер,1)),

	заполнить_пустые_места_случайным_образом(H,ВыходнаяЛиния),
	term_hash(ВыходнаяЛиния, Хэш),

	findall(Var,хэшсумма_линии(Номер,Var),ХэшиЛинии),
	\=(member(Хэш,ХэшиЛинии),true),
	assert(хэшсумма_линии(Номер, Хэш)),

	append(ПредыдущийСписок,
	      [ВыходнаяЛиния],
	      НовыйСписок),
	перебор_линий(Группы,T,ТекущийНомер,НовыйСписок,Выход).

%случай5: везде fail - начнём заново. Сгенерируем новое случайное
% расположение
перебор_линий(Группы,СписокЛиний,Номер,ПредыдущийСписок,Выход):-
	перебор_линий(Группы,СписокЛиний,Номер,ПредыдущийСписок,Выход).



/* == Группа предикатов ==
*  = по_одной_группе_имеют/3 =
* <Назначение>
   Подсчитывает сколько линий имеет лишь 1 группу закрашеных ячеек.
* </Назначение>
*/

по_одной_группе_имеют([],Колво1Групп,Колво1Групп).

%случай1: в данной линии одна группа, увеличить счётчик
по_одной_группе_имеют([H|T],Счётчик, Колво1Групп):-
	length(H,Длина),
	=:=(Длина,1),
	is(НовыйСчётчик, +(Счётчик,1)),
	по_одной_группе_имеют(T, НовыйСчётчик, Колво1Групп).

%случай2: в данной линии не одна группа,идем дальше
по_одной_группе_имеют([H|T],Счётчик, Колво1Групп):-
	length(H,Длина),
	=\=(Длина,1),
	по_одной_группе_имеют(T, Счётчик, Колво1Групп).


/* == Группа предикатов ==
*  = сколько_закрашенных_более/4 =
* <Назначение>
   Подсчитывает сколько линий, содержат в сумме в группах больше
   закрашенных ячеек, чем число в первом аргументе
* </Назначение>
*/

сколько_закрашенных_более(_,[],КолвоЗакрашенных,КолвоЗакрашенных).
%случай1: сумма в группах больше, чем первый аргумент
сколько_закрашенных_более(Клеток,[H|T],Счётчик, Колво1Групп):-
	sumlist(H,СуммаГрупп),
	>=(СуммаГрупп, Клеток),
	is(НовыйСчётчик, +(Счётчик,1)),
	сколько_закрашенных_более(Клеток,T, НовыйСчётчик, Колво1Групп).

%случай2: сумма в группах меньше, чем первый аргумент
сколько_закрашенных_более(Клеток,[H|T],Счётчик, Колво1Групп):-
	sumlist(H,СуммаГрупп),
	<(СуммаГрупп, Клеток),
	сколько_закрашенных_более(Клеток,T, Счётчик, Колво1Групп).


/* == Предикат ==
*  = узнать_количество_процентов/3 =
* <Назначение>
    Подсчитывает число процентов, которое составляет НекотороеЧисло от
    ОбщееЧисло.
*  </Назначение>
*/

узнать_количество_процентов(ОбщееЧисло, НекотороеЧисло, КоличествоПроцентов):-
	is(Y,ОбщееЧисло),
	is(Z, *(НекотороеЧисло,100)),
	is(КоличествоПроцентов, /(Z,Y)).




/* == Группа предикатов ==
*  = слж_закрасить_линию/4 =
* <Назначение>
   Закрашивает линию.
   Отличие от слж_закрасить_ячейки_с_номера/5: настоящая
   закрашивает линию в расчёте на то, что закрасится
   вся линия, все группы, с промежутками между
   группами в единицу. Вторая же закрашивает произвольные
   ячейки.

   Первый аргумент - список состояний линии
   Второй аргумент - список групп для линии
   Третий аргумент - счётчик
   Четвертый аргумент - выходной список состояний линии
* </Назначение>
*/


слж_закрасить_линию(ВыходнойСписок,[],_, ВыходнойСписок).

% случай1: счётчик не достиг длины линии
слж_закрасить_линию(СписокСостоянийЛинии,
		    [H|T],
		    Счётчик,
		    ВыходнойСписок):-
	изменить_ячейки_с_номера(СписокСостоянийЛинии,
			Счётчик,
			H,
			"Закрасить",
			ВыходнаяЛиния),
	is(НовыйСчётчик, +(Счётчик, H)),
	length(ВыходнаяЛиния, ДлинаЛинии),
	>=(ДлинаЛинии, НовыйСчётчик),
	изменить_ячейки_с_номера(ВыходнаяЛиния,
			НовыйСчётчик,
			1,
			"Не закрашена",
			ЕщёОднаВыходнаяЛиния),
	is(ЕщёОдинНовыйСчётчик, +(НовыйСчётчик, 1)),
	слж_закрасить_линию(ЕщёОднаВыходнаяЛиния,
			   T,
			   ЕщёОдинНовыйСчётчик,
			   ВыходнойСписок).



% случай2: счётчик ушёл за пределы линии
слж_закрасить_линию(СписокСостоянийЛинии,
		    [H|_],
		    Счётчик,
		    ВыходнойСписок):-
	изменить_ячейки_с_номера(СписокСостоянийЛинии,
			Счётчик,
			H,
			"Закрасить",
			ВыходнаяЛиния),

	is(НовыйСчётчик, +(Счётчик, H)),
	length(СписокСостоянийЛинии, ДлинаЛинии),
	<(ДлинаЛинии, НовыйСчётчик),
	=(ВыходнойСписок, ВыходнаяЛиния).


/* == Предикат ==
*  = узнать_количество_процентов/3 =
* <Назначение>
   Управляет предикатом слж_закрасить_линию/4.
*  </Назначение>
*/

закрасить_линию(СписокСостоянийЛинии,
	       СписокГрупп,
	       ВыходнойСписокСостояний):-
	слж_закрасить_линию(СписокСостоянийЛинии,СписокГрупп,1,ВыходнойСписокСостояний).




/* == Группа предикатов ==
*  = слж_примитивные_эвристики/3 =
* <Назначение>
   Прогоняют линии через небольшой набор примитивных
   эвристик. Эффективно в случае, когда много линий
   с малым числом групп (=<1),и закрашенных практически полностью линий.

   Первый аргумент - список состояний линии
   Второй аргумент - список групп для линии
   Третий аргумент - выходная линия
 </Назначение>
*/

слж_примитивные_эвристики([],[],_).

%случай1: в списке групп ничего нет
слж_примитивные_эвристики(СписокСостоянийЛинии,
			  СписокГрупп,
			 ВыходнаяЛиния):-
        length(СписокГрупп, ДлинаСписка),
	length(СписокСостоянийЛинии, ДлинаЛинии),
	=:=(ДлинаСписка, 0),
	изменить_ячейки_с_номера(СписокСостоянийЛинии,
		       1,
		       ДлинаЛинии,
		       "Не закрашена",
		       ВыходнаяЛиния).

%случай2: в группах одно число и оно равно длине линии
слж_примитивные_эвристики(СписокСостоянийЛинии,
			  СписокГрупп,
			  ВыходнаяЛиния):-
	length(СписокГрупп, ДлинаСписка),
	length(СписокСостоянийЛинии, ДлинаЛинии),
	=:=(ДлинаСписка, 1),
	nth1(1, СписокГрупп, Элемент),
	=:=(Элемент, ДлинаЛинии),
	изменить_ячейки_с_номера(СписокСостоянийЛинии,
		       1,
		       ДлинаЛинии,
		       "Закрасить",
		       ВыходнаяЛиния).




%случай3: в списке несколько чисел и они создают лишь один вариант
слж_примитивные_эвристики(СписокСостоянийЛинии,
			  СписокГрупп,
			  ВыходнаяЛиния):-
	length(СписокГрупп, ДлинаСписка),
	length(СписокСостоянийЛинии, ДлинаЛинии),
	>(ДлинаСписка, 1),
	sumlist(СписокГрупп, Сумма),
	is(X, ДлинаЛинии),
	is(Y, -(ДлинаСписка,1)),
	=:=(Сумма, -(X, Y)),
	закрасить_линию(СписокСостоянийЛинии,
		       СписокГрупп,
		       ВыходнаяЛиния).

%случай4: иной вариант
слж_примитивные_эвристики(СписокСостояний,_,СписокСостояний).


/* == Группа предикатов ==
*  = слж_примитивные_эвристики_столбцы/4 =
* <Назначение>
   Испытываем примитивные эвристики на столбцах

   Первый аргумент - список состояний линии
   Второй аргумент - список групп для линии
   Третий аргумент - промежуточный список
   Четвертый аргумент - выходная линия
 </Назначение>
*/
слж_примитивные_эвристики_столбцы([],_,ВыходнойСписок,ВыходнойСписок).
слж_примитивные_эвристики_столбцы([H|T],
				  [H2|T2],
				  ПредыдущийСписок,
				  ВыходнойСписок
				  ):-

	слж_примитивные_эвристики(H,
				  H2,
				  ВыходнаяЛиния),
	append(ПредыдущийСписок,
	      [ВыходнаяЛиния],
	      НовыйСписок),

	слж_примитивные_эвристики_столбцы(T,T2,НовыйСписок,ВыходнойСписок).


/* == Группа предикатов ==
*  = слж_примитивные_эвристики_строки/4 =
* <Назначение>
   Испытываем примитивные эвристики на строках

   Первый аргумент - список состояний линии
   Второй аргумент - список групп для линии
   Третий аргумент - промежуточный список
   Четвертый аргумент - выходная линия
 </Назначение>
*/
слж_примитивные_эвристики_строки([],_,ВыходнойСписок,ВыходнойСписок).
слж_примитивные_эвристики_строки([H|T],
				  [H2|T2],
				  ПредыдущийСписок,
				  ВыходнойСписок
				  ):-

	слж_примитивные_эвристики(H,
				  H2,
				  ВыходнаяЛиния),
	append(ПредыдущийСписок,
	      [ВыходнаяЛиния],
	      НовыйСписок),

	слж_примитивные_эвристики_строки(T,T2,НовыйСписок,ВыходнойСписок).


/* == Предикат ==
*  = примитивные_эвристики/6 =
* <Назначение>
   Испытываем примитивные эвристики на всём.
   Это интерфейсный предикат.
   Первый аргумент - список состояний линии
   Второй аргумент - список групп для линии
   Третий аргумент - промежуточный список
   Четвертый аргумент - выходная линия
 </Назначение>
*/
примитивные_эвристики(ВходнойСписокСтолбцы,
		      ВходнойСписокСтроки,
		      СписокГруппПоСтолбцам,
		      СписокГруппПоСтрокам,
		      ВыходнойСписокСтолбцы,
		      ВыходнойСписокСтроки):-
	слж_примитивные_эвристики_столбцы(ВходнойСписокСтолбцы,
				  СписокГруппПоСтолбцам,
				  [],
				  ВыходнойСписокСтолбцы),
	слж_примитивные_эвристики_строки(ВходнойСписокСтроки,
				  СписокГруппПоСтрокам,
				  [],
				  ВыходнойСписокСтроки).





/* == Предикат ==
*  = изменить_ячейки_с_номера/5 =
* <Назначение>
   Предикат создаёт новую линию, скопированную со входа,
   но с определенными заштрихованными(2) или отмеченными
   другим действием ячейками.

   Это интерфейсный предикат.
 </Назначение>
*/
изменить_ячейки_с_номера(СостоянияКлетокДо,
			 НомерСтартовойЯчейки,
			 КолвоИзменяемыхЯчеек,
			 Действие,
			 ВыходнойСписокЯчеек):-
        слж_изменить_ячейки_с_номера(СостоянияКлетокДо,
				     НомерСтартовойЯчейки,
				     КолвоИзменяемыхЯчеек,
				     Действие,
				     ВыходнойСписокЯчеек,
				     1,
				     []).



/* == Группа предикатов ==
*  = слж_изменить_ячейки_с_номера/7 =
* <Назначение>
   Служебный предикат для изменить_ячейки_с_номера/6
   Пользователям стоит выбирать последний класс, для
   внедрения в главный предикат решить_кроссворд/6


   Первый аргумент - список состояний ячеек
   Второй аргумент - номер стартовой ячейки
   Третий аргумент - количество изменяемых ячеек
   Четвертый аргумент - мнемоническое действие, производимое
                        над ячейками (в начале файла список действий)
   Пятый аргумент - выходной список ячеек
   Шестой аргумент - счётчик
   Седьмой аргумент - служебный список
 </Назначение>
*/

%случай1: находимся в диапазоне изменения
слж_изменить_ячейки_с_номера([_|T],
			     НомерСтартовойЯчейки,
			     КолвоИзменяемыхЯчеек,
			     Действие,
			     ВыходнойСписокЯчеек,
			     Счётчик,
			     ПредыдущийСписок):-
	=<(НомерСтартовойЯчейки,Счётчик),
	>(КолвоИзменяемыхЯчеек,0),

	findall(Состояние,
		значениеЯчейки(Действие,Состояние),
		ВременныйСписок),
	append(ПредыдущийСписок,
	       ВременныйСписок,
	       НовыйПредыдущийСписок),
	is(Счётчик1,+(Счётчик,1)),
	is(НовоеКолвоИзмЯчеек, -(КолвоИзменяемыхЯчеек,1)),

	слж_изменить_ячейки_с_номера(T,
				     НомерСтартовойЯчейки,
				     НовоеКолвоИзмЯчеек,
				     Действие,
				     ВыходнойСписокЯчеек,
				     Счётчик1,
				     НовыйПредыдущийСписок).

%случай2: находимся ДО диапазона изменения
слж_изменить_ячейки_с_номера([H|T],
			     НомерСтартовойЯчейки,
			     КолвоИзменяемыхЯчеек,
			     Действие,
			     ВыходнойСписокЯчеек,
			     Счётчик,
			     ПредыдущийСписок):-
	>(НомерСтартовойЯчейки,Счётчик),
	получить_мнемоническое_обозначение_ячейки(H,МнемОбозначение),
	findall(Состояние,
		значениеЯчейки(МнемОбозначение,Состояние),
		ВременныйСписок),

	append(ПредыдущийСписок,
	       ВременныйСписок,
	       НовыйПредыдущийСписок),
	is(Счётчик1,+(Счётчик,1)),
	слж_изменить_ячейки_с_номера(T,
				     НомерСтартовойЯчейки,
				     КолвоИзменяемыхЯчеек,
				     Действие,
				     ВыходнойСписокЯчеек,
				     Счётчик1,
				     НовыйПредыдущийСписок).



%случай3: находимся ПОСЛЕ диапазона изменения
слж_изменить_ячейки_с_номера([H|T],
			     НомерСтартовойЯчейки,
			     КолвоИзменяемыхЯчеек,
			     Действие,
			     ВыходнойСписокЯчеек,
			     Счётчик,
			     ПредыдущийСписок):-
	<(НомерСтартовойЯчейки,Счётчик),
	получить_мнемоническое_обозначение_ячейки(H, МнемЗначение),
	findall(Состояние,
		значениеЯчейки(МнемЗначение,Состояние),
		ВременныйСписок),
	append(ПредыдущийСписок,
	       ВременныйСписок,
	       НовыйПредыдущийСписок),
	is(Счётчик1,+(Счётчик,1)),
	слж_изменить_ячейки_с_номера(T,
				     НомерСтартовойЯчейки,
				     КолвоИзменяемыхЯчеек,
				     Действие,
				     ВыходнойСписокЯчеек,
				     Счётчик1,
				     НовыйПредыдущийСписок).

%случай4: список закончился, унификация выходного параметра
% и служебного списка
слж_изменить_ячейки_с_номера([],_,_,_,ВыходнойСписокЯчеек,_,ВыходнойСписокЯчеек).



/* == Группа предикатов ==
*  = получить_мнемоническое_обозначение_ячейки/2 =
* <Назначение>
    Возвращает мнемоническое обозначение ячейки по её
    коду
 </Назначение>
*/

%случай1: значение = "Не закрашена"
получить_мнемоническое_обозначение_ячейки(ЗначениеЯчейки,
					  ВыходноеЗначение):-

	=:=(ЗначениеЯчейки, 3),
	=(ВыходноеЗначение, "Не закрашена").

%случай2: значение = "Закрасить"
получить_мнемоническое_обозначение_ячейки(ЗначениеЯчейки,
					  ВыходноеЗначение):-

	=:=(ЗначениеЯчейки, 2),
	=(ВыходноеЗначение, "Закрасить").

%случай3: значение = "Возможно закрашена"
получить_мнемоническое_обозначение_ячейки(ЗначениеЯчейки,
					  ВыходноеЗначение):-

	=:=(ЗначениеЯчейки, 1),
	=(ВыходноеЗначение, "Возможно закрашена").

%случай4: значение = "Не пройдена"
получить_мнемоническое_обозначение_ячейки(ЗначениеЯчейки,
					  ВыходноеЗначение):-

	=:=(ЗначениеЯчейки, 0),
	=(ВыходноеЗначение, "Не пройдена").


